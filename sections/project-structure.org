* Structure of Augraphy

Augraphy is split into three parts: base, augmentations, and utilities. Together, these interact to allow practitioners to produce complex sequences of document image transformations, generating new synthetically-noisy datasets.

** From Documents to Pipeline Layers
Realistically reproducing effects in document images requires rethinking how those effects are produced in the real world. Many issues, like the various forms of misprint, only affect text and images on the page. Others, like a coffee spill, change properties of the paper itself. Further still, there are transformations like physical deformations which alter the geometry and topology of both the page material and the graphical artifacts on it.

Effectively capturing processes like these in reproducible augmentations meant separating our model of a document augmentation pipeline into ink, paper, and post-processing layers, each containing some augmentations that modify the document image as it passes through. Augraphy pipelines, then, are constructed from three sequences of augmentations, to be applied one after the other in each of those phases. After transformations occur to the ink and to the paper separately, the pipeline fuses them together, simulating the printing of that ink on that paper. Changes to the document after that point happen within the post layer, where we might find effects like crumpling up the page and smoothing it out again, or using a pen to underline a section of text.

** Base
The base classes exist to coordinate the compilation of discrete transformations into a larger pipeline, and to facilitate the operation and maintenance of these.

There are four "main sequence" classes in ~augraphy.base~, which together provide the bulk of the library's functionality. Two additional classes, ~OneOf~ and ~PaperFactory~, provide additional variation to pipelines in ways explored soon.

*** Augmentation
Augmentation is the most basic class in the project, and essentially exists as a thin wrapper over a probability value in the interval [0,1]. Every augmentation object is constructed with a probability of that augmentation being applied during the execution of a pipeline containing it.

This class also contains a method which interacts with the probability data, dynamically generating a second floating point probability value and using this to decide whether the augmentation should be applied at runtime.

*** AugmentationResult
After an augmentation is applied, the output of its execution is stored in an AugmentationResult object and passed forward through the pipeline. These objects also record an exact copy of the augmentation object that was instantiated and applied, as well as any metadata that might be relevant for debugging or other advanced use.

*** AugmentationSequence
A list of Augmentations -- together with the intent to apply those Augmentations in sequence -- determines an AugmentationSequence, which is itself both an Augmentation and callable. In practice, these are the model for the pipeline phases discussed previously; they are essentially lists of Augmentation constructor calls which produce callable Augmentation objects of the various flavors explored in [[Augmentations]]. AugmentationSequences are applied to the image during each of the [[AugmentationPipeline]] phases, and in each case yield the image, transformed by some of the Augmentations in the sequence.

*** AugmentationPipeline
The bulk of the innovation in Augraphy resides in the Augmentation pipeline, which is an abstraction over one or more events in a physical document's life. Events in this case could be the initial printing of the document when ink adhered to the paper material, or several weeks later when the document was adhered to a public board, annotated, defaced, and torn away from its securing staples. Fifty years later, our protagonist page resurfaces in the library archive during routine preservation-scanning efforts. Conservationists use delicate tools to gently position and record an image of the document, storing this in a public repository. An ~AugmentationPipeline~ can model this entire sequence of events, or any individual event within.

Use of the Augraphy library to produce a dataset for model training -- which will be covered in some detail later -- boils down to the definition and application of one or more Pipelines to one or more images.

*** OneOf
Real-world processes generally allow objects to exist in multiple states over time. To model the possibility that a document image has undergone one and only one of a collection of Augmentations, we use OneOf, which simply selects one of those Augmentations from a given list, and uses this to modify the image.

*** PaperFactory
We often print on multiple sizes and kinds of paper, and out in the world we certainly /encounter/ such diverse documents. We introduce this variation into the ~AugmentationPipeline~ by including ~PaperFactory~ in the ~paper~ phase of the pipeline. This augmentation checks a local directory for images of paper to crop and scale and use as a background for the document image. The pipeline contains edge detection logic for lifting only text and other foreground objects from a clean image, greatly simplifying the "printing" onto another "sheet". Taken together, ~PaperFactory~ makes it effectively possible to re-print a document onto other surfaces, like hemp paper, cardboard, or wood.

** Augmentations
The ~base~ modules provide scaffolding for working with general transformations on document images, called Augmentations. The Augraphy Team has already included many such transforms in the standard library, and has also provided [[Utilities][tools]] for easily building new augmentations and integrating them into the Augraphy workflow.

Augmentations come in many flavors and types, varying not only in their visual effect but in their software design. A brief profile of the project's augmentations continues below.

*** BadPhotoCopy
Produces noise blobs simulating a dirty copier.
*** BindingsAndFasteners
Creates marks like staples, paper clips, punched holes, and so on.
*** BleedThrough
Emulates ink bleeding through the page from the reverse side.
*** BookBinding
Creates the effect of a page curling away from the scanner bed, towards the binding of a book or magazine.
*** Brightness
Adjusts the brightness of the whole image by a chosen multiplier.
*** BrightnessTexturize
Creates a random noise in the brightness channel to emulate paper textures.
*** DirtyDrum
Emulates deposits of dirt and ink-grime from dirty printer drums.
*** DirtyRollers
Emulates an effect created by certain document scanners.
*** Dithering
Applies ordered or Floyd-Steinberg dithering to the input image.
*** DustyInk
Applies random noise to the ink itself, emulating a dusty or inconsistent ink tone when followed by a blur.
*** Faxify
Emulates the artifacts created by faxing the document.
*** Folding
Emulates folded paper being scanned, with a visible warp effect around the fold line.
*** Gamma
Randomly applies gamma correction (from a range of values) on the image.
*** Geometric
Applies basic geometric transformations such as resizing, flips and rotation.
*** Inkbleed
Relies on Sobel edge detection to create a mask of all edges, then applies random noise to those edges. When followed by a blur, this creates a fuzzy edge that emulates an ink bleed effect.
*** Jpeg
Uses JPEG encoding to create compression artifacts in the image.
*** Letterpress
Produces regions of ink mimicking the effect of ink pressed unevenly onto paper.
*** LightingGradient
Produces a decayed light mask generated by a light strip given position and direction, and applies it to the image as a lighting or brightness gradient.
*** LowInkBlobs
Creates random blobs of "low ink" that will be applied to the image.
*** LowInkPeriodicLines
Inherits from LowInkLine. Creates a set of lines that repeat in a periodic fashion throughout the image.
*** LowInkRandomLines
Inherits from LowInkLine. Adds lines randomly throughout the image.
*** Markup
Uses contour detection to detect text lines and add a smooth text strikethrough, highlight or underline effect.
*** NoiseTexturize
Creates a random noise based texture pattern to emulate paper textures.
*** PageBorder
Applies a shadow of underlying pages on any side of the page, creating an effect of single or multiple borders on specified side of the page.
*** PencilScribbles
Applies random pencil scribbles to image.
*** SubtleNoise
Emulates the imperfections in scanning solid colors due to subtle lighting differences.

** Utilities
